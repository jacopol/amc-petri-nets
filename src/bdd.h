#ifndef BDD_H
#define BDD_H

#include <cstdio>
#include <filesystem>

#include <sylvan_obj.hpp>

#include <pnml.h>

////////////////////////////////////////////////////////////////////////////////
// BDD Package                                                                //

////////////////////////////////////////////////////////////////////////////////
/// \brief   Initializes the BDD package.
///
/// \details Call this function before using any BDDs.
///
/// \brief places Number of places in the PNML file.
///
/// \brief bytes  Number of bytes of memory the BDD package may use.
////////////////////////////////////////////////////////////////////////////////
void bdd_init(const int places, const int bytes);

////////////////////////////////////////////////////////////////////////////////
/// \brief   Closes down and cleans up the BDD package down again.
///
/// \details Call this function before exiting the program.
////////////////////////////////////////////////////////////////////////////////
void bdd_deinit();

// BDD Package                                                                //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// BDD Class                                                                  //

////////////////////////////////////////////////////////////////////////////////
/// \brief   Binary Decision Diagram
///
/// \details This class takes care of updating the reference count based on the
///          object's lifetime (RAII).
////////////////////////////////////////////////////////////////////////////////
using bdd = sylvan::Bdd;

////////////////////////////////////////////////////////////////////////////////
/// \brief Collection of a relation and its variables as a BDD. Combined, these
///        are used together in the Relational Product.
////////////////////////////////////////////////////////////////////////////////
struct bdd_transition
{
  /// \brief Relation between 'before' and 'after' the relation
  bdd relation;

  /// \brief Set of variables involved in a BDD
  bdd var_cube;
};

// BDD Class                                                                  //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// BDD Constructors                                                           //

////////////////////////////////////////////////////////////////////////////////
/// \brief   BDD of the constant `false`.
///
/// \details This can be used to represent the empty set of markings.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_bot();

////////////////////////////////////////////////////////////////////////////////
/// \brief BDD of the constant `true`.
///
/// \details This can be used to the set of all possible markings.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_top();

////////////////////////////////////////////////////////////////////////////////
/// \brief Obtain the BDD for a single variable, *l*.
///
/// \param p        The variable, i.e. the place in the PNML.
///
/// \param is_prime Whether the variable is *primed*, i.e. whether it is a
///                 *next* or just a *current* state variable.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_var(int p, bool is_prime = false);

////////////////////////////////////////////////////////////////////////////////
/// \brief Converts a PNML marking into its BDD representation.
///
/// \param marking The marking to convert into a BDD.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_convert(const pnml::marking_type &marking);

////////////////////////////////////////////////////////////////////////////////
/// \brief Converts a PNML transition into its BDD representation.
///
/// \param transition The transition to convert into a BDD.
////////////////////////////////////////////////////////////////////////////////
bdd_transition
bdd_convert(const pnml::transition_type &transition);

// BDD Constructors                                                           //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// BDD Operations                                                             //

////////////////////////////////////////////////////////////////////////////////
/// \brief Negation of a BDD.
///
/// \remark Alternatively, use the `~` operator overloading.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_not(const bdd& f);

////////////////////////////////////////////////////////////////////////////////
/// \brief Conjunction of two BDDs.
///
/// \remark Alternatively, use the `&` and `&=` operator overloadings.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_and(const bdd& f, const bdd& g);

////////////////////////////////////////////////////////////////////////////////
/// \brief Disjunction of two BDDs.
///
/// \remark Alternatively, use the `|` and `|=` operator overloadings.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_or(const bdd& f, const bdd& g);

////////////////////////////////////////////////////////////////////////////////
/// \brief Difference between two BDDs.
///
/// \remark Alternatively, use the `-` and `-=` operator overloadings.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_diff(const bdd& f, const bdd& g);

////////////////////////////////////////////////////////////////////////////////
/// \brief Test if BDD f is contained in BDD g.
///
/// \remark Alternatively, use the `<=` operator overloading.
////////////////////////////////////////////////////////////////////////////////
bool
bdd_subset(const bdd& f, const bdd& g);

////////////////////////////////////////////////////////////////////////////////
/// \brief Apply transition relation `t` to states `s` to obtain `Next(s)`.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_relnext(const bdd& s, const bdd_transition& t);

////////////////////////////////////////////////////////////////////////////////
/// \brief Apply transition relation `t` to states `s` to obtain `Prev(s)`.
////////////////////////////////////////////////////////////////////////////////
bdd
bdd_relprev(const bdd& s, const bdd_transition& t);

////////////////////////////////////////////////////////////////////////////////
/// \brief Number of satisfying solutions in a BDD, i.e. number of states in
///        the set.
////////////////////////////////////////////////////////////////////////////////
double
bdd_satcount(const bdd& f);

// BDD Operations                                                             //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// BDD Debugging                                                              //

////////////////////////////////////////////////////////////////////////////////
/// \brief Print dot file of BDD to a C-style I/O stream
////////////////////////////////////////////////////////////////////////////////
void
bdd_printdot(const bdd& f, FILE *out = stdout);

void
bdd_printdot(const bdd& f, const std::filesystem::path& path);

void
bdd_printdot(const bdd_transition& f, FILE* out = stdout);

void
bdd_printdot(const bdd_transition& f, const std::filesystem::path& path);

// BDD Debugging                                                              //
////////////////////////////////////////////////////////////////////////////////

#endif // BDD_H
